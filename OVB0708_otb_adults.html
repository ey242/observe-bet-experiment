<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Observe-then-Bet</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        line-height: 1.6;
        margin: 0;
        padding: 20px;
        max-width: 800px;
        margin: 0 auto;
      }

      .hidden {
        display: none !important; 
      }

      button {
        margin: 10px 0;
        padding: 10px 20px;
        font-size: 16px;
        cursor: pointer;
        border: 1px solid #ccc;
        background-color: #f8f8f8;
        border-radius: 5px;
      }

      button:hover {
        background-color: #e8e8e8;
      }

      .button-container {
        display: flex;
        justify-content: center;
        gap: 20px;
        margin-top: 10px;
        margin-bottom: 10px;
      }

      /* Removed video styles as videos are removed */

      form {
        display: flex;
        flex-direction: column;
      }

      form input, form textarea {
        margin-bottom: 10px;
        padding: 8px;
        border: 1px solid #ccc;
        border-radius: 4px;
        font-size: 16px;
      }

      .how-to-play-list img {
          width: 30px; /* Adjust this value as needed */
          height: auto;
          vertical-align: middle; /* Aligns the image with the text */
      }

      .game-container {
        display: grid;
        gap: 15px; /* Gap between outcome images */
        justify-content: center;
        max-width: 700px; /* Adjusted for observation grid */
        margin: 0 auto;
        padding: 20px;
        border: 1px solid #e0e0e0;
        border-radius: 8px;
        background-color: #f9f9f9;
        grid-template-columns: repeat(8, 1fr); /* 8 columns for outcomes */
      }

      .observation-outcome-grid {
        display: grid;
        grid-template-columns: repeat(8, 1fr); /* 8 columns for outcomes */
        gap: 10px;
        margin-bottom: 20px;
        max-width: 700px;
        margin-left: auto;
        margin-right: auto;
      }

      .outcome-image {
        width: 70px; /* Size of individual outcome images */
        height: 70px;
        object-fit: contain;
        border: 1px solid #ddd;
        border-radius: 4px;
        padding: 5px;
        background-color: white;
      }

      .observation-controls {
        text-align: center;
        margin-top: 20px;
      }

      .glasses-icon-button {
        background: none;
        border: none;
        padding: 0;
        cursor: pointer;
        outline: none;
      }

      .glasses-icon-button img {
        width: 100px; /* Larger icon for clicking */
        height: 100px;
        display: block;
        margin: 0 auto;
      }

      .betting-trial-container {
        display: flex;
        justify-content: center;
        gap: 20px;
        margin-top: 20px;
      }

      .betting-door {
        width: 120px;
        height: 120px;
        cursor: pointer;
        border: 2px solid transparent;
        border-radius: 8px;
        transition: border-color 0.2s;
      }

      .betting-door:hover {
        border-color: #007bff;
      }

      .betting-door.chosen {
        border-color: #28a745; 
        box-shadow: 0 0 10px rgba(40, 167, 69, 0.5);
      }

      .instruction-page, .session-summary, .final-summary, .practice-screen {
        text-align: center;
        margin: 20px auto;
        max-width: 800px;
      }

      /* Smaller font for instruction paragraphs */
      .instruction-page p, .practice-screen p {
        font-size: 15px; /* Adjusted font size */
      }

      .summary-grid {
        display: grid; /* Changed to grid */
        grid-template-columns: repeat(5, 1fr); /* 5 columns */
        gap: 10px;
        justify-content: center;
        align-items: start;
        max-width: 700px; 
        margin: 0 auto;
        margin-top: 20px;
        border: 1px solid #eee;
        padding: 10px;
        border-radius: 8px;
      }

      .summary-round-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        border: 1px solid black; /* Black border around each round */
        padding: 5px;
        border-radius: 5px;
      }

      .summary-item {
        display: flex;
        flex-direction: column;
        align-items: center;
        width: 100%; 
      }

      .summary-img {
        width: 50px;
        height: 50px;
        object-fit: contain;
        margin-bottom: 5px;
      }

      .summary-label, .summary-number {
        font-size: 12px;
        margin: 2px 0;
      }

      /* Custom Modal Styles */
      .custom-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0,0,0,0.6);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1001;
      }

      .custom-modal-content {
        background-color: white;
        padding: 30px;
        border-radius: 10px;
        text-align: center;
        max-width: 500px;
        box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        position: relative;
      }

      .custom-modal-content textarea {
        width: calc(100% - 20px);
        min-height: 100px;
        margin-top: 15px;
        padding: 10px;
        border: 1px solid #ddd;
        border-radius: 5px;
        resize: vertical;
      }

      .custom-modal-content button {
        margin-top: 20px;
        padding: 10px 25px;
        font-size: 16px;
        border-radius: 5px;
        cursor: pointer;
        background-color: #007bff;
        color: white;
        border: none;
      }

      /* Observation confidence probe: no blackout, bottom-floating card */
      #obs-confidence-modal {
        background-color: transparent;      /* no dark overlay */
        align-items: flex-end;              /* push to bottom */
        justify-content: center;            /* center horizontally */
        pointer-events: auto;               /* still clickable */
      }

      #obs-confidence-modal .custom-modal-content {
        max-width: 520px;
        margin-bottom: 40px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.25);
      }
      
      .custom-modal-content button:hover {
        background-color: #0056b3;
      }

      .practice-ready-to-bet-button {
        margin-top: 50px; /* Adjust this value as needed */
      }
    </style>
  </head>
  <body>
    <div id="consent-screen"> 
        <div style="max-width: 95%; margin: 0 auto; padding: 20px; font-size: 18px; text-align: left;">
            <p style="text-align: center; font-size: 25px;">
                <strong>Adult Consent Form</strong>
                <br>
                <br>
                <strong>Causal Learning in Children</strong>
                <br>
                <strong>CPHS # 2010-01-631</strong>
                <br> 
                <br>
                <span style="float: right;"><strong>Adult mTurk Prolific</strong></span>
                <br style="clear: both;"> 
                <br>
            </p>
            <p style="text-align: center; font-size: 25px;">
                <strong>Key information</strong>
            </p>
            <p>
                &bull; You are being invited to participate in a research study. Participation in research is completely 
                voluntary.
            </p>
            
            <p>
                &bull; The purpose of the study is to examine how adults infer and interpret cause and effect and how adults understand the thoughts and feelings of other people.
            </p>
            <p>
                &bull; The study will take a total of 1-4 testing sessions (but usually it is just one session) that will last no longer than 30 minutes each and you will be asked to play interactive games designed for both kids and adults. Sometimes you may receive payment incentives based on your choices, responses, or decisions. You may be asked to
                watch a short video clip, look at pictures, or listen to music, and you may be asked to answer questions about how the clip or music made you feel.
            </p>
            <p>
                &bull; Risks and/or discomforts may include the risk of breach of confidentiality.
            </p>
            <p>
                &bull; There is no direct benefit to you. The results from the study may contribute to improving our understanding of the way people make judgments about cause and effect.
            </p>
            <br>
            <br>
            <p style="text-align: center; font-size: 25px;">
                <strong>Purpose of the Study</strong>
            </p>
            <p>
                <strong>Dear Participant,</strong>
            </p>
            <p>
                This study is being conducted by Alison Gopnik, professor of psychology at the University of California, Berkeley, and her laboratory of research assistants, graduate students, and postdoctoral fellows. We invite you to participate in a study of how adults infer and interpret cause and effect and how adults understand the thoughts and feelings of other people. Please read the following information carefully and select the button below indicating whether you wish to participate in the study. Participation is entirely voluntary. If anything is not clear, please do not hesitate to ask questions.
            </p>
            <br>
            <p style="text-align: center; font-size: 25px;">
                <strong>Study Procedures</strong>
            </p>
            <p>
                There can be up to 4 testing sessions (but usually it is just one session) that will last no longer than 30 minutes each. This study is designed to test hypotheses about the way people make judgments about cause and effect in a variety of contexts and about other peoples&apos; minds and behavior.  
                <br>
                <br>
                You may be asked to do one or more of the following tasks 1) causal learning tasks (e.g., figuring out what causes what), 2) linguistic tasks (e.g., word associations and learning), 3) imagination tasks (e.g., reasoning about events counter to fact), 4) categorization/ association tasks (e.g., grouping objects or stating what comes to mind given a prompt), 5) general cognitive tasks (e.g., impulse control and searching for hidden objects). You may be asked to make judgments about what you see, answer questions about your judgments (such as making predictions and providing explanations), observe events, and perform actions yourself (such as grouping objects or making machines activate). Sometimes you might watch a short video clip, look at pictures, or listen to music, and you may be asked to answer questions about how the clip or music made you feel. 
                <br>
                <br>
                You may refrain from answering any questions that make you uncomfortable and may withdraw your participation at any time even after completing the experiment without penalty.
                <br>
                <br>
                This study contains a number of checks to make sure that participants are finishing the tasks honestly and completely. As long as you read the instructions and complete the tasks, your submission will be approved. If you fail these checks, your submission will be rejected and you will not be compensated for responses entered.
                <br>
                <br>
                Study time: Your study participation will take a total of 1-4 testing sessions (but usually it is just one session) that will last no longer than 30 minutes each.
                <br>
                <br>
                Study location: All study procedures will take place online. 
            </p>
            <p style="text-align: center; font-size: 25px;">
                <strong>Benefits</strong>
            </p>
            <p>
                While there is no direct benefit to you, you may enjoy the novelty of our interactive displays. You will also be making a substantial contribution to improving our understanding of the way people make judgments about cause and effect.
            </p>
            <p style="text-align: center; font-size: 25px;">
                <strong>Risks/Discomforts</strong>
            </p>
            <p>
                We do not expect you to face any foreseeable risks from your participation. There is the unlikely possibility that your confidentiality will be compromised; however, we have taken measures to minimize this risk. 
            </p>
            <br>
            <p style="text-align: center; font-size: 25px;">
                <strong>Confidentiality</strong>
            </p>
            <p>
                Your identity will be separated from your data and a random numerical code will be assigned to keep track of the data. Your confidentiality will be kept to the degree permitted by the technology being used. No guarantees can be made regarding the interception of data sent via the Internet by any third parties. Data will be kept indefinitely. All information will be securely stored at the University in encrypted format. Physical data and information collected during the research will be encrypted and securely stored electronically both online and on an external hard drive as a back up. The external hard drive will be securely stored at the University in locked file cabinets, and housed in secure rooms. Only laboratory personnel will have access to this data. No individuals will be identified in any presentation or publication. Identifiers might be removed from the identifiable private information. After such removal, the information could be used for future research studies or distributed to other investigators for future research studies without additional informed consent from the subject or the legally authorized representative.
            </p>
            <br>
            <p>
                <strong>
                    Your personal information may be released if required by law. Authorized representatives from the following organizations may review your research data for purposes such as monitoring or managing the conduct of this study:
                </strong>
            </p>
            <p>
                <strong>
                    &bull; Sponsors: National Science Foundation, Mind Science Foundation, Princeton University, Defense Advanced Research Projects Agency (DARPA) 
                </strong>
            </p>
            <p>
                <strong>
                    &bull; University of California
                </strong>
            </p>
            <br>
            <p style="text-align: center; font-size: 25px;">
                <strong>Costs of Study Participation</strong>
            </p>
            <p>
                There are no costs associated with study participation.
            </p>
            <br>
            <p style="text-align: center; font-size: 25px;">
                <strong>Compensation</strong>
            </p>
            <p>
                For your participation in our research, you will receive a maximum rate of $8 per hour. Payment ranges from $0.54 to $0.67 for a 5-minute task and from $3.25 to $4.00 for a 30-minute task, depending on the time it takes to complete the type of task you&apos;ve been assigned. For studies on Prolific, you will receive a minimum rate of $6.50 per hour. For experiments with a differential bonus payment system you may have the opportunity to earn &quot;points&quot; that are worth up to 5 cents each, with a total bonus of no more than 30 cents paid on top of the flat fee paid for the task completion. Your online account will be credited directly.
            </p>
            <br>
            <p style="text-align: center; font-size: 25px;">
                <strong>Rights</strong>
            </p>
            <p>
                Please understand that your participation in the research is voluntary and that you are free to withdraw your consent and discontinue participation in the research at any time. If you decide not to participate, there will be no penalty or loss of benefits to which you are otherwise entitled.
            </p>
            <br>
            <p style="text-align: center; font-size: 25px;">
                <strong>Questions</strong>
            </p>
            <p>
                If you have any questions at this point, please contact the lab at 643-2172 or Professor Alison Gopnik (642-2752), or email us at one of the addresses listed at the end of this form, if you have any questions or concerns later. 
            </p>
            <br>
            <p>
                If you have any question regarding your treatment or rights as a participant in this research project, please contact the Committee for the Protection of Human Subjects at the University of California at Berkeley at phone: (510) 642-7461, or at subjects@berkeley.edu.
            </p>
            <br>
            <p>
                Thank you for your time.
            </p>
            <br>
            <p>
                Sincerely,
            </p>
            <br>
            <p>
                Alison Gopnik
            </p>
            <p>
                Professor
            </p>
            <p>
                Psychology Department
            </p>
            <p>
                University of California, Berkeley
            </p>
            <p>
                Additional Contact Information:
            </p>
            <p>
                Alison Gopnik, Principal Investigator: gopnik@berkeley.edu
            </p>
            <p>
                Laboratory Manager: gopniklabmanager@berkeley.edu
            </p>
            <br>
            <p style="text-align: center;">
                <strong>
                    By selecting the &quot;Accept&quot; button below, I acknowledge that I am 18 or older, have read this consent form, and I agree to take part in the research. If you do NOT agree to participate in this study, please click the &quot;Decline&quot; button below.
                </strong>
            </p>
            <div class="button-container">
                <button id="consent-button">Accept</button>
                <button id="decline-button">Decline</button>
            </div>
        </div>
    </div> <div id="experiment-container">
      <div id="participant-info" class="hidden">
        <h2>Participant Information</h2>
        <form id="info-form">
          <label for="SID">Prolific ID</label> <input type="text" id="SID" name="SID" required>
          <label for="age">Participant Age (years)</label>
          <input type="text" id="age" name="age" required>
          <label for="sex">Participant Sex</label>
          <input type="text" id="sex" name="sex" placeholder="M/F" required>
          <button type="submit">Submit</button>
        </form>
      </div>

 <div id="pretrial" class="hidden">
        <img src="https://github.com/ey242/OVB/raw/main/public/stim/coin_boxes.png" alt="Coin Boxes" style="width: 750px;">
        <p>Look at these two boxes and meet this wizard! His name is One Box. One Box Wizard only likes to hide coins in the same box. Your job is to find out which box the coins are in so you can win them!</p>
        <p>Are you ready to play the game?</p>
        <button id="ready-button">Continue</button> <!-- Changed to Continue -->
      </div>

      <!-- New Practice Observation Screen -->
     <div id="practice-observation-screen" class="practice-screen hidden">
      <h2>Practice Game</h2>
      <h3>How to Play</h3>
      <p>A shiny coin is hidden in one of these two boxes. Your job is to find out which box it’s in so you can win it!</p>
      <ol class="how-to-play-list">
        <li><strong>Peek to Learn</strong>: Click on the <img src="https://github.com/ey242/OVB/raw/main/public/pics/Glasses1.png" alt="Glasses icon"> button below to peek and see which box hides the coin. You can peek as many times as you like. But remember, One Box Wizard only hides coins in the same box!</li>
        <li><strong>Make Your Guess</strong>: When you think you know where the coins go, click on that box to guess. Once you start guessing, you can’t peek again.</li>
        <li><strong>See Your Score</strong>: At the end of this game, we’ll count how many coins you found.</li>
      </ol>
      <p>Are you ready? Click the glasses to start peeking! <br>Remember, you can click it as much as you want!</p>
      <div id="practice-observation-outcomes-display" class="observation-outcome-grid"></div>
      <div class="observation-controls">
        <button class="glasses-icon-button" id="practice-observe-button">
          <img src="https://github.com/ey242/OVB/raw/main/public/pics/Glasses1.png" alt="Observe">
        </button>
        <br>
        <br>
        <br>
        <br>
        <br>
        <br>
        <button id="practice-ready-to-bet-button" class="continue-button hidden">I’m done watching and ready to guess!</button>
    </div>
  </div>

      <!-- New Practice Betting Screen -->
      <div id="practice-betting-screen" class="practice-screen hidden">
        <h2>Practice Betting</h2> <!-- Changed headline -->
        <p>Now, based on what you watched, guess on where the coin is hiding for <span id="practice-bet-total-rounds"></span> rounds. You won’t find out which box the coin is in until you’ve finished guessing!</p>
        <div id="practice-betting-outcomes-display" class="observation-outcome-grid">
        </div>
        <p>Practice Betting Round <span id="current-practice-betting-round">1</span> of <span id="practice-bet-total-rounds-display"></span></p>
        <div class="betting-trial-container">
          <img src="https://github.com/ey242/OVB/raw/main/public/stim/GreenBox.png" alt="Green Box" class="betting-door practice-bet-door" data-door="green">
          <img src="https://github.com/ey242/OVB/raw/main/public/stim/PurpleBox.png" alt="Purple Box" class="betting-door practice-bet-door" data-door="purple">
        </div>
      </div>

      <!-- New Practice Summary Screen -->
      <div id="practice-summary-screen" class="session-summary hidden">
        <h2 id="practice-summary-title">Practice Summary</h2> <!-- Changed headline -->
        <p id="practice-coins-earned-display"></p>
        <div id="practice-summary-details">
          <h3>Betting Outcomes:</h3> <!-- Re-added headline -->
        </div>
        <button id="practice-summary-continue-button" class="continue-button">Start Game!</button>
      </div>

      <!-- Dynamic Instruction Page for Sessions 1 & 2 -->
      <div id="session-instruction-page" class="instruction-page hidden">
        <img id="session-instruction-image" src="" alt="" style="width: 800px;">
        <p id="session-instruction-text-1"></p>
        <p id="session-instruction-text-2"></p>
        <p id="session-instruction-text-3"></p>
        <p id="session-instruction-text-4"></p>
        <p id="session-instruction-text-5"></p>
        <button id="start-session-button" class="continue-button">Ready</button>
      </div>

      <!-- New Observation Screen -->
      <div id="observation-screen" class="instruction-page hidden">
        <h2 id="observation-title"></h2> <!-- Dynamic title -->
        <p id="observation-instruction-text"></p> <!-- Dynamic instruction -->
        <div id="observation-outcomes-display" class="observation-outcome-grid">
          <!-- Observed outcomes will be displayed here -->
        </div>
        <div class="observation-controls">
          <button class="glasses-icon-button" id="observe-button">
            <img src="https://github.com/ey242/OVB/raw/main/public/pics/Glasses1.png" alt="Observe">
          </button>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <button id="ready-to-bet-button" class="continue-button hidden">I'm done watching and ready to guess!</button> 
        </div>
      </div>

      <!-- New Betting Screen -->
      <div id="betting-screen" class="instruction-page hidden">
        <h2 id="betting-title">Session Betting</h2> <!-- Simplified title -->
        <p>Now, based on what you watched, guess on where the character is hiding for 10 rounds.</p>
        <div id="observation-outcomes-display-betting" class="observation-outcome-grid">
          <!-- Observed outcomes will remain displayed here, and betting choices will be appended -->
        </div>
        <p>Round <span id="current-betting-round">1</span> of 10</p>
        <div class="betting-trial-container" id="betting-doors-container">
          <!-- Doors will be dynamically loaded here based on character -->
        </div>
      </div>

      <!-- Session Summary Screen -->
      <div id="session-summary-screen" class="session-summary hidden">
        <h2 id="session-summary-title">Summary</h2> 
        <p id="session-coins-earned"></p>
        <div id="betting-summary-details">
          <h3>Betting Outcomes:</h3> <!-- Re-added headline -->
        </div>
        <button id="session-continue-button" class="continue-button">Continue</button>
      </div>

      <!-- Final Summary Screen -->
      <div id="final-summary-screen" class="final-summary hidden">
        <h2>Congratulations! You did a great job looking for the coins!</h2>
        <p id="final-coins-earned"></p>
        <button id="final-continue-button" class="continue-button">Submit Experiment and Finish</button>
        <p>Please don't close the window until you see a pop up message with the completion code.</p>
      </div>
    </div>

    <!-- Custom Modal for Alerts -->
    <div id="custom-alert-modal" class="custom-modal hidden">
      <div class="custom-modal-content">
        <p id="custom-alert-message"></p>
        <button id="custom-alert-ok-button">OK</button>
      </div>
    </div>

    <!-- Custom Confirm Modal -->
    <div id="custom-confirm-modal" class="custom-modal hidden">
      <div class="custom-modal-content">
        <p id="custom-confirm-message"></p>
        <div>
          <button id="custom-confirm-yes-button">Yes</button>
          <button id="custom-confirm-no-button">No</button>
        </div>
      </div>
    </div>

    <!-- Observation Confidence Modal -->
    <div id="obs-confidence-modal" class="custom-modal hidden">
      <div class="custom-modal-content">
        <p id="obs-confidence-question">
          How sure are you right now about how the character is hiding?
        </p>
        <div id="obs-confidence-options"
            style="text-align:left; margin-top:10px; font-size:16px;">
          <label><input type="radio" name="obs_conf" value="1">
            1 – Not sure at all</label><br>
          <label><input type="radio" name="obs_conf" value="2">
            2 – A little sure</label><br>
          <label><input type="radio" name="obs_conf" value="3">
            3 – Kind of sure</label><br>
          <label><input type="radio" name="obs_conf" value="4">
            4 – Very sure</label><br>
          <label><input type="radio" name="obs_conf" value="5">
            5 – Super sure (as sure as you can be)</label>
        </div>
        <button id="obs-confidence-submit">OK</button>
      </div>
    </div>

    <!-- Custom Modal for Explanations (+ confidence) -->
    <div id="explanation-modal" class="custom-modal hidden">
      <div class="custom-modal-content">
        <p id="explanation-modal-question">
          Based on what you watched, how do you think the ${characterName} hides?
        </p>

        <textarea id="explanation-text" placeholder="Type your explanation here..."></textarea>

        <div style="margin-top:14px;text-align:left;">
          <label for="explanation-confidence" style="font-weight:bold;">How sure are you about how the ${characterName} hides?</label>
          <div id="explanation-confidence" style="margin-top:8px;">
            <label><input type="radio" name="rule_conf" value="1" required> 1 (not sure at all)</label><br>
            <label><input type="radio" name="rule_conf" value="2"> 2 (a little sure)</label><br>
            <label><input type="radio" name="rule_conf" value="3"> 3 (kind of sure)</label><br>
            <label><input type="radio" name="rule_conf" value="4"> 4 (very sure)</label><br>
            <label><input type="radio" name="rule_conf" value="5"> 5 (super sure, as sure as you can be)</label>
          </div>
        </div>

        <button id="submit-explanation-button">Submit</button>
      </div>
    </div>

    <script>
      // --- Utility Functions for Custom Modals ---
      /**
       * Displays a custom alert modal with a given message.
       * @param {string} message - The message to display in the alert.
       * @param {function} [callback] - Optional callback function to execute when the OK button is clicked.
       */
      function showCustomAlert(message, callback) {
          const modal = document.getElementById('custom-alert-modal');
          const msgElement = document.getElementById('custom-alert-message');
          const okButton = document.getElementById('custom-alert-ok-button');

          msgElement.textContent = message;
          modal.classList.remove('hidden'); // Show the modal

          const handleOkClick = () => {
              modal.classList.add('hidden'); // Hide the modal
              okButton.removeEventListener('click', handleOkClick); // Clean up event listener
              if (callback) callback(); // Execute callback if provided
          };

          okButton.addEventListener('click', handleOkClick);
      }

      /**
       * Displays a custom confirmation modal with a given message and handles user's choice.
       * @param {string} message - The message to display in the confirmation dialog.
       * @param {function} onConfirm - Callback function to execute if the user clicks 'Yes'.
       * @param {function} [onCancel] - Optional callback function to execute if the user clicks 'No'.
       */
      function showCustomConfirm(message, onConfirm, onCancel) {
          const modal = document.getElementById('custom-confirm-modal');
          const msgElement = document.getElementById('custom-confirm-message');
          const yesButton = document.getElementById('custom-confirm-yes-button');
          const noButton = document.getElementById('custom-confirm-no-button');

          msgElement.textContent = message;
          modal.classList.remove('hidden'); // Show the modal

          const handleYesClick = () => {
              modal.classList.add('hidden'); // Hide the modal
              yesButton.removeEventListener('click', handleYesClick);
              noButton.removeEventListener('click', handleNoClick);
              if (onConfirm) onConfirm(); // Execute onConfirm callback
          };

          const handleNoClick = () => {
              modal.classList.add('hidden'); // Hide the modal
              yesButton.removeEventListener('click', handleYesClick);
              noButton.removeEventListener('click', handleNoClick);
              if (onCancel) onCancel(); // Execute onCancel callback
          };

          yesButton.addEventListener('click', handleYesClick);
          noButton.addEventListener('click', handleNoClick);
      }

      /**
       * Shows the observation confidence probe (1–5) and returns the rating via callback.
       * Asked "every other" observation trial.
       */
      function showObsConfidenceModal(characterName, trialIndex, callback) {
        const modal = document.getElementById('obs-confidence-modal');
        const question = document.getElementById('obs-confidence-question');
        const submitBtn = document.getElementById('obs-confidence-submit');

        // Character-specific, simple wording
        question.textContent =
          `How sure are you right now about how the ${characterName} is hiding?`;

        // Reset radio buttons
        document
          .querySelectorAll('input[name="obs_conf"]')
          .forEach(r => { r.checked = false; });

        modal.classList.remove('hidden');

        const handleSubmit = () => {
          const checked = document.querySelector('input[name="obs_conf"]:checked');
          if (!checked) return; // require a choice before continuing

          const rating = parseInt(checked.value, 10);
          modal.classList.add('hidden');
          submitBtn.removeEventListener('click', handleSubmit);

          if (callback) callback(rating);
        };

        submitBtn.addEventListener('click', handleSubmit);
      }

      /**
       * Displays the explanation modal and captures user input.
       * @param {function} callback - Callback function to execute with the explanation text when submitted.
       * @param {string} characterName - The name of the character for the explanation question (e.g., 'elf', 'princess').
       */
      function showExplanationModal(callback, characterName) {
        const modal = document.getElementById('explanation-modal');
        const textarea = document.getElementById('explanation-text');
        const submitButton = document.getElementById('submit-explanation-button');
        const questionElement = document.getElementById('explanation-modal-question');

        // Character-aware prompt
        questionElement.textContent =
          `Based on what you watched, what do you think the rule is for how the ${characterName} hides?`;

        // Reset inputs
        textarea.value = '';
        Array.from(document.querySelectorAll('input[name="rule_conf"]')).forEach(r => r.checked = false);

        modal.classList.remove('hidden');

        const handleSubmit = () => {
          const confEl = document.querySelector('input[name="rule_conf"]:checked');
          const confidence = confEl ? confEl.value : '';
          if (!confidence) return; // require a confidence selection

          modal.classList.add('hidden');
          submitButton.removeEventListener('click', handleSubmit);
          if (callback) callback({ text: textarea.value.trim(), confidence });
        };

        submitButton.addEventListener('click', handleSubmit);
      }

      // --- Global Variables ---
      const MAX_OBSERVATIONS = 104; // Upper limit for observations for both practice and main sessions
      const BETTING_ROUNDS = 10;
      const PRACTICE_ROUNDS = 4; // Number of rounds for practice betting

      let participantInfo = {};
      let sessionData = {
        sessionA: {
          pattern: '', // 'alternating' or 'random'
          character: '', // 'elf' or 'princess'
          observationOutcomes: [],
          observationRTs: [],        // ← track each observe click
          obsConfidence: [],
          explanation: '',
          confidence: '',
          bettingChoices: [],
          bettingRealities: [],
          bettingRTs: [],            // ← track each bet click
          coinsEarned: 0
        },
        sessionB: {
          pattern: '', // 'alternating' or 'random'
          character: '', // 'elf' or 'princess'
          observationOutcomes: [],
          observationRTs: [],        // ← track each observe click
          obsConfidence: [],
          explanation: '',
          confidence: '',
          bettingChoices: [],
          bettingRealities: [],
          bettingRTs: [],            // ← track each bet click
          coinsEarned: 0
        }
      };
      let currentSessionType = ''; // 'sessionA' or 'sessionB'
      let sessionOrder = []; // Will be randomized ['sessionA', 'sessionB']
      let currentSessionIndex = 0;
      let currentObservationStartTime = 0;
      let currentBettingStartTime     = 0;

      let currentObservationCount = 0;
      let currentBettingRound = 0;
      let currentBettingTrials = []; // Stores the 10 realities for betting phase
      let currentObservationSequence = []; // Stores the pre-generated sequence for alternating observation

      // Practice specific variables
      let currentPracticeObservationCount = 0;
      let practiceObservedOutcomes = [];
      let practiceObservationRTs = [];
      let practiceObservationStartTime = 0;
      let currentPracticeBettingRound = 0;
      let practiceBettingChoices = [];
      let practiceBettingRealities = [];
      let practiceBettingRTs = [];
      let practiceBettingStartTime     = 0;
      let practiceCoinsEarned = 0;
      let practiceObservationSequence = []; // Stores the pre-generated sequence for practice observation
      let practiceCoinColor = ''; // 'green' or 'purple' - determined randomly at start of practice

      /**
       * Shuffles an array in place.
       * @param {Array} array - The array to shuffle.
       */
      function shuffleArray(array) {
          for (let i = array.length - 1; i > 0; i--) {
              const j = Math.floor(Math.random() * (i + 1));
              [array[i], array[j]] = [array[j], array[i]];
          }
      }

      /**
       * Generates a sequence of trials for observation or betting.
       * @param {number} numTrials - The total number of trials to generate.
       * @param {string} characterType - 'elf', 'princess', or 'coin' for practice.
       * @param {string} [patternType] - Optional: 'alternating' or 'random' for trials.
       * @param {string} [startOutcome] - Optional: The outcome to start the alternating pattern with.
       * @returns {Array<string>} An array of strings representing the rewarded door for each trial.
       */
      function generateTrials(numTrials, characterType, patternType = 'random', startOutcome = null) {
          let trials = [];
          let door1, door2;

          if (characterType === 'elf') {
              door1 = 'brown';
              door2 = 'blue';
          } else if (characterType === 'princess') {
              door1 = 'red';
              door2 = 'yellow';
          } else if (characterType === 'coin') { // For practice session, use the globally set practiceCoinColor
              for (let i = 0; i < numTrials; i++) {
                  trials.push(practiceCoinColor); // Use the randomly assigned practiceCoinColor
              }
              return trials; // Return early for coin character
          }

          if (patternType === 'alternating') {
              let initialBettingOutcome;
              if (startOutcome) {
                  // If last observed was door1, first betting outcome is door2.
                  // If last observed was door2, first betting outcome is door1.
                  initialBettingOutcome = (startOutcome === door1) ? door2 : door1;
              } else {
                  // If no startOutcome provided (e.g., for observation session itself), default to door1
                  initialBettingOutcome = door1;
              }

              let currentOutcome = initialBettingOutcome;
              for (let i = 0; i < numTrials; i++) {
                  trials.push(currentOutcome);
                  // Alternate the outcome for the next trial
                  currentOutcome = (currentOutcome === door1) ? door2 : door1;
              }
          } else { // 'random' with no more than 3 consecutive same outcomes
              let lastOutcome = '';
              let consecutiveCount = 0;
              for (let i = 0; i < numTrials; i++) {
                  let currentOutcome;
                  if (consecutiveCount >= 3) {
                      // Force the alternative outcome
                      currentOutcome = (lastOutcome === door1) ? door2 : door1;
                      consecutiveCount = 1; // Reset count for the new outcome
                  } else {
                      // Randomly pick an outcome
                      currentOutcome = Math.random() < 0.5 ? door1 : door2;
                      if (currentOutcome === lastOutcome) {
                          consecutiveCount++;
                      } else {
                          consecutiveCount = 1;
                      }
                  }
                  trials.push(currentOutcome);
                  lastOutcome = currentOutcome;
              }
          }
          return trials;
      }

      /**
       * Displays a specific screen by hiding all others.
       * @param {string} id - The ID of the screen to show.
       */
      function showScreen(id) {
          document.querySelectorAll(
            '#consent-screen,' +                // hide consent screen too
            '#experiment-container > div,' +
            '.custom-modal,' +
            '.practice-screen,' +
            '.instruction-page,' +
            '.session-summary,' +
            '.final-summary,' +
            '.instruction-div'
          ).forEach(screen => {
            screen.classList.add('hidden');
          });
          document.getElementById(id).classList.remove('hidden');
        }
      /**
       * Adds a quit button to the top right of the screen.
       */
      function addQuitButton() {
        const quitButton = document.createElement('button');
        quitButton.textContent = 'Quit';
        quitButton.id = 'quit-button';
        quitButton.style.position = 'fixed';
        quitButton.style.bottom = '10px'; // Changed to bottom
        quitButton.style.right = '10px';
        quitButton.style.zIndex = '1000';
        quitButton.style.backgroundColor = '#808080'; // Grey background
        quitButton.style.color = '#FFFFFF'; // White text
        quitButton.addEventListener('click', handleQuit);
        document.body.appendChild(quitButton);
      }

      /**
       * Handles the quit button click, confirming with the user and saving data.
       */
      function handleQuit() {
        // Example hook right after user clicks "I'm done watching...":
        showCustomConfirm(
          "Are you sure you’ve watched enough to know how to win coins?",
          () => {
            // figure out the current session's character string ('elf' or 'princess')
            const charForThisSession = sessionData[currentSessionType].character; // you already set this earlier
            const characterDisplay = (charForThisSession === 'elf') ? 'elf' : 'princess';

            showExplanationModal(({ text, confidence }) => {
              // store into sessionData (adult file: add the confidence field)
              sessionData[currentSessionType].explanation = text || '';
              sessionData[currentSessionType].confidence = confidence || '';

              // now proceed to betting
              startBettingSession(currentSessionType);
            }, characterDisplay);
          }
        );
      }

      // --- Session Management ---

      /**
       * Initializes the experiment by setting up session order and starting the first instruction.
       */
      function initializeExperiment() {
        sessionOrder = ['sessionA', 'sessionB'];
        shuffleArray(sessionOrder); // Randomize session order

        // Assign patterns and characters to sessions
        const patterns = ['alternating', 'random'];
        shuffleArray(patterns);
        const characters = ['elf', 'princess'];
        shuffleArray(characters);

        sessionData.sessionA.pattern = patterns[0];
        sessionData.sessionA.character = characters[0];
        sessionData.sessionB.pattern = patterns[1];
        sessionData.sessionB.character = characters[1];

        console.log('Session Order:', sessionOrder);
        console.log('Session A Pattern:', sessionData.sessionA.pattern, 'Character:', sessionData.sessionA.character);
        console.log('Session B Pattern:', sessionData.sessionB.pattern, 'Character:', sessionData.sessionB.character);
        
        // Start with the pretrial screen
        showScreen('pretrial');
      }

      /**
       * Starts the practice observation session.
       */
      function startPracticeObservation() {
        currentPracticeObservationCount = 0;
        practiceObservedOutcomes = [];
        // Randomly determine the fixed coin color for the practice session
        practiceCoinColor = Math.random() < 0.5 ? 'green' : 'purple';
        console.log('Practice Coin Color (Fixed):', practiceCoinColor);

        // Generate practice sequence using the determined fixed color
        practiceObservationSequence = generateTrials(MAX_OBSERVATIONS, 'coin', 'fixed'); 
        console.log('Practice Observation Sequence:', practiceObservationSequence);

        document.getElementById('practice-observation-outcomes-display').innerHTML = '';
        document.getElementById('practice-observe-button').addEventListener('click', handlePracticeObserve);
        document.getElementById('practice-ready-to-bet-button').classList.add('hidden'); // Hide until first observation
        document.getElementById('practice-ready-to-bet-button').addEventListener('click', handlePracticeReadyToBet);
        showScreen('practice-observation-screen');
        practiceObservationStartTime = performance.now();

      }

      /**
       * Handles observation in the practice session.
       */
      function handlePracticeObserve() {
        if (currentPracticeObservationCount >= MAX_OBSERVATIONS) {
            showCustomAlert("You have watched the most you can watch for this practice session.");
            return;
        }

         const rt = performance.now() - practiceObservationStartTime;
         practiceObservationRTs.push(rt);

        const outcomesDisplay = document.getElementById('practice-observation-outcomes-display');
        const outcome = practiceObservationSequence[currentPracticeObservationCount]; // Get outcome from pre-generated sequence

        practiceObservedOutcomes.push(outcome);
        currentPracticeObservationCount++;

        const img = document.createElement('img');
        img.src = outcome === 'green' ? 'https://github.com/ey242/OVB/raw/main/public/stim/GreenBoxCoin.png' : 'https://github.com/ey242/OVB/raw/main/public/stim/PurpleBoxCoin.png';
        img.alt = `Coin in ${outcome} box`;
        img.className = 'outcome-image';
        outcomesDisplay.appendChild(img);

        // Show "I'm done watching and ready to guess!" button after at least one observation
        if (currentPracticeObservationCount > 0) {
            document.getElementById('practice-ready-to-bet-button').classList.remove('hidden');
        }
      }

      /**
       * Handles the "I'm done watching and ready to guess!" button click for the practice session.
       */
      function handlePracticeReadyToBet() {
        document.getElementById('practice-observe-button').removeEventListener('click', handlePracticeObserve);
        document.getElementById('practice-ready-to-bet-button').removeEventListener('click', handlePracticeReadyToBet);
        startPracticeBetting();
      }

      /**
       * Starts the practice betting session.
       */
      function startPracticeBetting() {
        currentPracticeBettingRound = 0;
        practiceBettingChoices = [];
        practiceBettingRealities = [];
        practiceCoinsEarned = 0;

        document.getElementById('practice-bet-total-rounds').textContent = PRACTICE_ROUNDS;
        document.getElementById('practice-bet-total-rounds-display').textContent = PRACTICE_ROUNDS;
        document.getElementById('current-practice-betting-round').textContent = currentPracticeBettingRound + 1;

        const bettingOutcomesDisplay = document.getElementById('practice-betting-outcomes-display');
        bettingOutcomesDisplay.innerHTML = ''; // Clear it

        // Display observed outcomes from practice observation phase
        practiceObservedOutcomes.forEach(outcome => {
            const img = document.createElement('img');
            img.src = outcome === 'green' ? 'https://github.com/ey242/OVB/raw/main/public/stim/GreenBoxCoin.png' : 'https://github.com/ey242/OVB/raw/main/public/stim/PurpleBoxCoin.png';
            img.alt = `Observed ${outcome} box`;
            img.className = 'outcome-image';
            bettingOutcomesDisplay.appendChild(img);
        });

        document.querySelectorAll('.practice-bet-door').forEach(door => {
          door.classList.remove('chosen'); // Reset chosen state
          door.addEventListener('click', handlePracticeBet);
        });

        showScreen('practice-betting-screen');
        practiceBettingStartTime = performance.now();

      }

      /**
       * Handles betting in the practice session.
       * @param {Event} event - The click event.
       */
      function handlePracticeBet(event) {
        if (currentPracticeBettingRound >= PRACTICE_ROUNDS) {
            showCustomAlert("Practice betting rounds are complete. Please click 'Start Game!'");
            return;
        }

        const chosenDoor = event.target.dataset.door;
        const reality = practiceObservationSequence[currentPracticeBettingRound]; // Use practiceObservationSequence for reality

        practiceBettingChoices.push(chosenDoor);
        practiceBettingRealities.push(reality);

        const rt = performance.now() - practiceBettingStartTime;
        practiceBettingRTs.push(rt);
        practiceBettingStartTime = performance.now();


        const bettingOutcomesDisplay = document.getElementById('practice-betting-outcomes-display');
        const chosenDoorImg = document.createElement('img');
        chosenDoorImg.src = chosenDoor === 'green' ? 'https://github.com/ey242/OVB/raw/main/public/stim/GreenBox.png' : 'https://github.com/ey242/OVB/raw/main/public/stim/PurpleBox.png';
        chosenDoorImg.alt = `Chosen ${chosenDoor} box`;
        chosenDoorImg.className = 'outcome-image';
        bettingOutcomesDisplay.appendChild(chosenDoorImg);

        if (chosenDoor === reality) {
            practiceCoinsEarned++;
        }

        currentPracticeBettingRound++;
        document.getElementById('current-practice-betting-round').textContent = currentPracticeBettingRound + 1;

        if (currentPracticeBettingRound >= PRACTICE_ROUNDS) {
            endPracticeBetting();
        }
      }

      /**
       * Ends the practice betting session and provides a summary.
       */
      function endPracticeBetting() {
        document.querySelectorAll('.practice-bet-door').forEach(door => {
            door.removeEventListener('click', handlePracticeBet);
        });
        showPracticeSummary();
      }

      /**
       * Displays the summary for the practice session.
       */
      function showPracticeSummary() {
        document.getElementById('practice-coins-earned-display').textContent = `Coins earned: ${practiceCoinsEarned} out of ${PRACTICE_ROUNDS}`; 
        
        const practiceSummaryDetails = document.getElementById('practice-summary-details');
        practiceSummaryDetails.innerHTML = '<h3>Betting Outcomes:</h3>'; // Re-added headline

        const allBettingOutcomesGrid = document.createElement('div');
        allBettingOutcomesGrid.className = 'summary-grid';

        for (let i = 0; i < practiceBettingChoices.length; i++) {
          const roundContainer = document.createElement('div');
          roundContainer.className = 'summary-round-container';

          // Your Choice (Door)
          const chosenItem = document.createElement('div');
          chosenItem.className = 'summary-item';
          const chosenLabel = document.createElement('p');
          chosenLabel.textContent = `Your Choice:`; 
          const chosenImg = document.createElement('img');
          chosenImg.src = practiceBettingChoices[i] === 'green' ? 'https://github.com/ey242/OVB/raw/main/public/stim/GreenBox.png' : 'https://github.com/ey242/OVB/raw/main/public/stim/PurpleBox.png';
          chosenImg.alt = practiceBettingChoices[i];
          chosenImg.className = 'summary-img';
          chosenItem.appendChild(chosenLabel);
          chosenItem.appendChild(chosenImg);
          roundContainer.appendChild(chosenItem);

          // Reality (Coin)
          const realityItem = document.createElement('div');
          realityItem.className = 'summary-item';
          const realityLabel = document.createElement('p');
          realityLabel.textContent = `Reality:`; 
          const realityImg = document.createElement('img');
          realityImg.src = practiceBettingRealities[i] === 'green' ? 'https://github.com/ey242/OVB/raw/main/public/stim/GreenBoxCoin.png' : 'https://github.com/ey242/OVB/raw/main/public/stim/PurpleBoxCoin.png';
          realityImg.alt = practiceBettingRealities[i];
          realityImg.className = 'summary-img';
          realityItem.appendChild(realityLabel);
          realityItem.appendChild(realityImg);
          roundContainer.appendChild(realityItem);

          allBettingOutcomesGrid.appendChild(roundContainer);
        }
        practiceSummaryDetails.appendChild(allBettingOutcomesGrid);
        
        {
          const contBtn = document.getElementById('practice-summary-continue-button');

          // Avoid double-binding if the summary is shown more than once
          contBtn.replaceWith(contBtn.cloneNode(true));
          const freshContinue = document.getElementById('practice-summary-continue-button');

          freshContinue.addEventListener('click', () => {
            // practiceCoinsEarned and PRACTICE_ROUNDS are already defined in your file
            if (practiceCoinsEarned === PRACTICE_ROUNDS) {
              // Perfect 4/4 → proceed to the main session instructions
              showSessionInstruction(sessionOrder[currentSessionIndex]);
            } else {
              // Not perfect → repeat the practice loop
              showCustomAlert(
                "Let's try the practice again to make sure the rules are clear. You’ll continue until you get all 4 coins.",
                 () => {
                    startPracticeObservation();
                  }
              );
            }
          });
        }
        showScreen('practice-summary-screen');
      }

      /**
       * Dynamically sets content for the session instruction page.
       * @param {string} sessionType - 'sessionA' or 'sessionB'.
       */
      function showSessionInstruction(sessionType) {
          const session = sessionData[sessionType];
          const character = session.character; // 'elf' or 'princess'
          const imageElement = document.getElementById('session-instruction-image');
          const text1 = document.getElementById('session-instruction-text-1');
          const text2 = document.getElementById('session-instruction-text-2');
          const text3 = document.getElementById('session-instruction-text-3');
          const text4 = document.getElementById('session-instruction-text-4');
          const text5 = document.getElementById('session-instruction-text-5');
          const startButton = document.getElementById('start-session-button');

          let characterDisplayName = character;
          let characterImageSrc = '';

          if (character === 'elf') {
              characterDisplayName = 'kind elf';
              characterImageSrc = 'https://github.com/ey242/OVB/raw/main/public/stim/elf_doors.png';
          } else if (character === 'princess') {
              characterDisplayName = 'kind princess';
              characterImageSrc = 'https://github.com/ey242/OVB/raw/main/public/stim/princess_doors.png';
          }

          imageElement.src = characterImageSrc;
          imageElement.alt = `${characterDisplayName} Doors`;

          text1.textContent = `Now we have a ${characterDisplayName}! Look at these two doors. The ${characterDisplayName} will hide behind one of them each time.`;
          text2.textContent = `Unlike the One Box Wizard, the ${characterDisplayName} has ${character === 'elf' ? 'its' : 'her'} very own special pattern for hiding so the hiding door can change. ${character === 'elf' ? 'It' : 'She'} will give you a coin every time you guess the right door ${character === 'elf' ? 'it' : 'she'} hides behind.`;
          text3.textContent = `Your job is to win as many coins as you can! To do this, you'll first get to watch and see which door the ${characterDisplayName} is behind and learn how ${character === 'elf' ? 'it' : 'she'} hides.`;
          text4.textContent = `When you're done watching, you'll guess which door you think the ${characterDisplayName} is behind to try and win a coin! Once you start guessing, you can't go back to watching.`;
          text5.textContent = `You won't find out which door actually hid the ${characterDisplayName} until you finish all your guesses, and then we'll tell you how many coins you won. Each coin you win = $0.01 bonus payment. Are you ready to meet the ${characterDisplayName} and win coins?`;
          
          // Remove previous event listener to prevent multiple bindings
          startButton.removeEventListener('click', handleStartSessionButtonClick);
          startButton.addEventListener('click', handleStartSessionButtonClick);

          showScreen('session-instruction-page');
      }

      /**
       * Handles the click of the "Ready" button on the dynamic session instruction page.
       */
      function handleStartSessionButtonClick() {
          startObservationSession(sessionOrder[currentSessionIndex]);
      }


      /**
       * Starts an observation session.
       * @param {string} sessionType - 'sessionA' or 'sessionB'.
       */
      function startObservationSession(sessionType) {
        currentSessionType = sessionType;
        currentObservationCount = 0;
        sessionData[currentSessionType].observationOutcomes = []; // clear
        sessionData[currentSessionType].observationRTs = [];
        sessionData[currentSessionType].obsConfidence = []; 
        currentObservationStartTime = performance.now();

        // Pre-generate observation sequence from the session’s assigned character & pattern
        currentObservationSequence = generateTrials(
          MAX_OBSERVATIONS,
          sessionData[currentSessionType].character,
          sessionData[currentSessionType].pattern
        );
        console.log(
          `Observation Sequence for ${currentSessionType} (${sessionData[currentSessionType].pattern}):`,
          currentObservationSequence
        );

        // Dynamic title + instruction (clean copy)
        const characterDisplayName =
          sessionData[currentSessionType].character === 'elf' ? 'elf' : 'princess';
        document.getElementById('observation-title').textContent =
          `Watch where the ${characterDisplayName} hides`;
        document.getElementById('observation-instruction-text').textContent =
          `Click the glasses to watch which door the ${characterDisplayName} is hiding behind. You can click as much as you want!`;

        // Reset outcome list
        document.getElementById('observation-outcomes-display').innerHTML = '';

        // Rebind the "observe" button to avoid duplicate listeners on re-entry
        {
          const observeBtn = document.getElementById('observe-button');
          observeBtn.replaceWith(observeBtn.cloneNode(true));
          const freshObserveBtn = document.getElementById('observe-button');
          freshObserveBtn.addEventListener('click', handleObserveClick);
        }

        // Prepare the "ready to bet" button
        const readyBtn = document.getElementById('ready-to-bet-button');
        readyBtn.classList.add('hidden'); // stays hidden until the first observation elsewhere
        readyBtn.textContent = "I'm done watching and ready to guess!";

        // Rebind to our custom confirm -> explanation modal -> betting flow
        readyBtn.replaceWith(readyBtn.cloneNode(true));
        const freshReadyBtn = document.getElementById('ready-to-bet-button');
        freshReadyBtn.addEventListener('click', (e) => {
          e.preventDefault();

          // Use your custom confirm (must exist in your file; same one the kids build uses)
          showCustomConfirm(
            "Are you sure you’ve watched enough to know how to win coins?",
            () => {
              const charName = sessionData[currentSessionType].character; // 'elf' or 'princess'

              // Character-aware explanation + confidence modal (same helper as kids build)
              showExplanationModal(({ text, confidence }) => {
                sessionData[currentSessionType].explanation = text || '';
                sessionData[currentSessionType].confidence = confidence || '';

                startBettingSession(currentSessionType);
              }, charName);
            }
          );
        });

        showScreen('observation-screen');
      }


      /**
       * Handles the click on the "glasses" icon during observation.
       */
      function handleObserveClick() {
        // If we’ve already hit the max, show alert and exit immediately
        if (currentObservationCount >= MAX_OBSERVATIONS) {
          showCustomAlert("You have watched the most you can watch for this session.");
          return;
        }

        // ——— Record reaction time ———
        const rtObs = performance.now() - currentObservationStartTime;
        sessionData[currentSessionType].observationRTs.push(rtObs);

        // ——— Existing logic ———
        const outcomesDisplay = document.getElementById('observation-outcomes-display');
        const outcome = currentObservationSequence[currentObservationCount];
        
        sessionData[currentSessionType].observationOutcomes.push(outcome);
        currentObservationCount++;
        
        // reset timer for the next observation
        currentObservationStartTime = performance.now();

        // render the image
        const img = document.createElement('img');
        if (sessionData[currentSessionType].character === 'elf') {
          img.src = outcome === 'brown'
            ? 'https://github.com/ey242/OVB/raw/main/public/stim/elfbrown.png'
            : 'https://github.com/ey242/OVB/raw/main/public/stim/elfblue.png';
        } else {
          img.src = outcome === 'red'
            ? 'https://github.com/ey242/OVB/raw/main/public/stim/princessred.png'
            : 'https://github.com/ey242/OVB/raw/main/public/stim/princessyellow.png';
        }
        img.alt = outcome;
        img.className = 'outcome-image';
        outcomesDisplay.appendChild(img);

        // reveal the “ready to bet” button once they’ve seen at least two observations
        if (currentObservationCount > 1) {
          document.getElementById('ready-to-bet-button').classList.remove('hidden');
        }

        if (currentObservationCount % 3 === 0) {
          const charName = sessionData[currentSessionType].character === 'elf'
            ? 'elf'
            : 'princess';

          showObsConfidenceModal(charName, currentObservationCount, (rating) => {
            sessionData[currentSessionType].obsConfidence.push({
              trialIndex: currentObservationCount,
              rating: rating
            });
          });
        }
      }


      /**
       * Handles the "I'm done watching and ready to guess!" button click, transitioning to explanation.
       */
      function handleReadyToBet() {
        document.getElementById('observe-button').removeEventListener('click', handleObserveClick);
        document.getElementById('ready-to-bet-button').removeEventListener('click', handleReadyToBet);
        // Pass the character name to the explanation modal
        showExplanationModal(handleExplanationSubmitted, sessionData[currentSessionType].character);
      }

      /**
       * Callback after explanation is submitted, transitions to betting.
       * @param {string} explanationText - The text entered by the participant.
       */
      function handleExplanationSubmitted(explanationText) {
        sessionData[currentSessionType].explanation = explanationText;
        startBettingSession(currentSessionType);
      }

      /**
       * Starts a betting session.
       * @param {string} sessionType - 'sessionA' or 'sessionB'.
       */
      function startBettingSession(sessionType) {
        currentSessionType = sessionType;
        currentBettingRound = 0;
        sessionData[currentSessionType].bettingChoices = [];
        sessionData[currentSessionType].bettingRealities = [];
        sessionData[currentSessionType].coinsEarned = 0;

        document.getElementById('betting-title').textContent = `Session ${currentSessionType === 'sessionA' ? 1 : 2} Betting`; // Simplified title
        document.getElementById('current-betting-round').textContent = currentBettingRound + 1;

        currentBettingStartTime = performance.now();  

        // Display observed outcomes from the current session in the shared display area
        const sharedOutcomesDisplay = document.getElementById('observation-outcomes-display-betting');
        sharedOutcomesDisplay.innerHTML = ''; // Clear it once to ensure clean start for betting screen
        
        // Populate the betting display with observation outcomes first
        sessionData[currentSessionType].observationOutcomes.forEach(outcome => {
            const img = document.createElement('img');
            // Use the correct character image based on the session's character
            if (sessionData[currentSessionType].character === 'elf') {
                img.src = outcome === 'brown' ? 'https://github.com/ey242/OVB/raw/main/public/stim/elfbrown.png' : 'https://github.com/ey242/OVB/raw/main/public/stim/elfblue.png';
            } else { // princess
                img.src = outcome === 'red' ? 'https://github.com/ey242/OVB/raw/main/public/stim/princessred.png' : 'https://github.com/ey242/OVB/raw/main/public/stim/princessyellow.png';
            }
            img.alt = outcome;
            img.className = 'outcome-image';
            sharedOutcomesDisplay.appendChild(img);
        });

        // Generate the 10 realities for the betting phase based on the session's assigned pattern
        let lastObservedOutcome = null;
        if (sessionData[currentSessionType].observationOutcomes.length > 0) {
            lastObservedOutcome = sessionData[currentSessionType].observationOutcomes[sessionData[currentSessionType].observationOutcomes.length - 1];
        }

        currentBettingTrials = generateTrials(BETTING_ROUNDS, sessionData[currentSessionType].character, sessionData[currentSessionType].pattern, lastObservedOutcome);
        console.log(`Current Betting Trials (Realities) for ${currentSessionType} (${sessionData[currentSessionType].pattern}):`, currentBettingTrials);

        // Dynamically load betting doors
        const bettingDoorsContainer = document.getElementById('betting-doors-container');
        bettingDoorsContainer.innerHTML = ''; // Clear existing doors

        if (sessionData[currentSessionType].character === 'elf') {
            bettingDoorsContainer.innerHTML = `
                <img src="https://github.com/ey242/OVB/raw/main/public/stim/browndoor.png" alt="Brown Door" class="betting-door" data-door="brown">
                <img src="https://github.com/ey242/OVB/raw/main/public/stim/bluedoor.png" alt="Blue Door" class="betting-door" data-door="blue">
            `;
        } else { // princess
            bettingDoorsContainer.innerHTML = `
                <img src="https://github.com/ey242/OVB/raw/main/public/stim/reddoor.png" alt="Red Door" class="betting-door" data-door="red">
                <img src="https://github.com/ey242/OVB/raw/main/public/stim/yellowdoor.png" alt="Yellow Door" class="betting-door" data-door="yellow">
            `;
        }

        document.querySelectorAll('.betting-door').forEach(door => {
          door.classList.remove('chosen'); // Reset chosen state
          door.addEventListener('click', handleBettingClick);
        });

        showScreen('betting-screen');  // remove the stray "s" here
    }

      /**
       * Handles a door click during the betting phase.
       * @param {Event} event - The click event.
       */
      function handleBettingClick(event) {
        const chosenDoor = event.target.dataset.door;
        const reality = currentBettingTrials[currentBettingRound];
        const characterType = sessionData[currentSessionType].character;
        const rtBet = performance.now() - currentBettingStartTime;
        sessionData[currentSessionType].bettingRTs.push(rtBet);

        sessionData[currentSessionType].bettingChoices.push(chosenDoor);
        sessionData[currentSessionType].bettingRealities.push(reality);

        // Append the chosen door image to the shared outcomes display
        const sharedOutcomesDisplay = document.getElementById('observation-outcomes-display-betting');
        const chosenImg = document.createElement('img');
        
        if (characterType === 'elf') {
            chosenImg.src = chosenDoor === 'brown' ? 'https://github.com/ey242/OVB/raw/main/public/stim/browndoor.png' : 'https://github.com/ey242/OVB/raw/main/public/stim/bluedoor.png';
        } else { // princess
            chosenImg.src = chosenDoor === 'red' ? 'https://github.com/ey242/OVB/raw/main/public/stim/reddoor.png' : 'https://github.com/ey242/OVB/raw/main/public/stim/yellowdoor.png';
        }
        chosenImg.alt = `Chosen ${chosenDoor}`;
        chosenImg.className = 'outcome-image';
        sharedOutcomesDisplay.appendChild(chosenImg);

        // Check for reward
        if (chosenDoor === reality) {
          sessionData[currentSessionType].coinsEarned++;
        }

        currentBettingRound++;
        document.getElementById('current-betting-round').textContent = currentBettingRound + 1;

        if (currentBettingRound < BETTING_ROUNDS) {
          // Continue to next betting round
          // No need for a timeout or resetting chosen state on doors, as new images are appended.
          currentBettingStartTime = performance.now(); 
        } else {
          // Betting phase complete
          document.querySelectorAll('.betting-door').forEach(door => {
            door.removeEventListener('click', handleBettingClick);
          });
          showSessionSummary();
        }
      }

      /**
       * Displays the summary for the current session.
       */
      function showSessionSummary() {
        document.getElementById('session-summary-title').textContent = `Summary`; 
        document.getElementById('session-coins-earned').textContent = `Coins earned: ${sessionData[currentSessionType].coinsEarned} out of ${BETTING_ROUNDS}`; 
        
        const bettingSummaryDetails = document.getElementById('betting-summary-details');
        bettingSummaryDetails.innerHTML = '<h3>Betting Outcomes:</h3>'; // Re-add headline

        const session = sessionData[currentSessionType];
        // Create a single grid for all betting outcomes
        const allBettingOutcomesGrid = document.createElement('div');
        allBettingOutcomesGrid.className = 'summary-grid';

        for (let i = 0; i < session.bettingChoices.length; i++) {
          const roundContainer = document.createElement('div');
          roundContainer.className = 'summary-round-container';

          // Your Choice (Door)
          const chosenItem = document.createElement('div');
          chosenItem.className = 'summary-item';
          const chosenLabel = document.createElement('p');
          chosenLabel.textContent = `Your Choice:`; 
          const chosenImg = document.createElement('img');
          if (session.character === 'elf') {
              chosenImg.src = session.bettingChoices[i] === 'brown' ? 'https://github.com/ey242/OVB/raw/main/public/stim/browndoor.png' : 'https://github.com/ey242/OVB/raw/main/public/stim/bluedoor.png';
          } else { // princess
              chosenImg.src = session.bettingChoices[i] === 'red' ? 'https://github.com/ey242/OVB/raw/main/public/stim/reddoor.png' : 'https://github.com/ey242/OVB/raw/main/public/stim/yellowdoor.png';
          }
          chosenImg.alt = session.bettingChoices[i];
          chosenImg.className = 'summary-img';
          chosenItem.appendChild(chosenLabel);
          chosenItem.appendChild(chosenImg);
          roundContainer.appendChild(chosenItem);

          // Reality (Character)
          const realityItem = document.createElement('div');
          realityItem.className = 'summary-item';
          const realityLabel = document.createElement('p');
          realityLabel.textContent = `Reality:`; 
          const realityImg = document.createElement('img');
          if (session.character === 'elf') {
              realityImg.src = session.bettingRealities[i] === 'brown' ? 'https://github.com/ey242/OVB/raw/main/public/stim/elfbrown.png' : 'https://github.com/ey242/OVB/raw/main/public/stim/elfblue.png';
          } else { // princess
              realityImg.src = session.bettingRealities[i] === 'red' ? 'https://github.com/ey242/OVB/raw/main/public/stim/princessred.png' : 'https://github.com/ey242/OVB/raw/main/public/stim/princessyellow.png';
          }
          realityImg.alt = session.bettingRealities[i];
          realityImg.className = 'summary-img';
          realityItem.appendChild(realityLabel);
          realityItem.appendChild(realityImg);
          roundContainer.appendChild(realityItem);

          allBettingOutcomesGrid.appendChild(roundContainer);
        }
        bettingSummaryDetails.appendChild(allBettingOutcomesGrid);


        document.getElementById('session-continue-button').addEventListener('click', handleSessionContinue);
        showScreen('session-summary-screen');
      }

      /**
       * Handles the continue button click after a session summary.
       */
      function handleSessionContinue() {
        document.getElementById('session-continue-button').removeEventListener('click', handleSessionContinue);
        currentSessionIndex++;
        if (currentSessionIndex < sessionOrder.length) {
          // Start the next session's instructions
          showSessionInstruction(sessionOrder[currentSessionIndex]);
        } else {
          // All sessions complete, show final summary
          showFinalSummary();
        }
      }

      /**
       * Displays the final summary of the experiment.
       */
      function showFinalSummary() {
        const totalCoins = sessionData.sessionA.coinsEarned + sessionData.sessionB.coinsEarned;
        document.getElementById('final-coins-earned').textContent = `You won: ${totalCoins} out of ${BETTING_ROUNDS * 2}`;
        document.getElementById('final-continue-button').addEventListener('click', saveDataToCSV);
        showScreen('final-summary-screen');
      }

      // --- Data Generation Functions ---
      function generateObservationSequence(pattern, count) {
        const sequence = [];
        for (let i = 0; i < count; i++) {
          if (pattern === 'alternating') {
            sequence.push(i % 2 === 0 ? 'green' : 'purple');
          } else { // 'random'
            sequence.push(Math.random() < 0.5 ? 'green' : 'purple');
          }
        }
        return sequence;
      }

      function saveDataToCSV() {
        const header = [
          'Participant ID', 'Participant Age', 'Participant Sex',
          'Session Type', 'Session Pattern', 'Session Character', 
          'Trial Type', 'Trial Index', 'Player Choice', 
          'Actual Outcome', 'Coins Earned This Trial', 
          'Reaction Time (ms)', 'Explanation', 'Confidence', 'Session Total Coins'
        ];

        const dataRows = [];

        const baseParticipantInfo = [
          participantInfo.SID || '',
          participantInfo.age || '',
          participantInfo.sex || ''
        ];

        // Helper function to add rows for a given session
        function addSessionRows(sessionName, sessionDataObj, isPractice = false) {
          const sessionPattern = isPractice ? `Fixed` : sessionDataObj.pattern;
          const sessionCharacter = isPractice ? 'coin' : sessionDataObj.character;

          // Observation rows
          sessionDataObj.observationOutcomes.forEach((outcome, index) => {
            let obsConf = '';

            if (!isPractice && sessionDataObj.obsConfidence && sessionDataObj.obsConfidence.length) {
              const probe = sessionDataObj.obsConfidence.find(
                c => c.trialIndex === index + 1
              );
              if (probe) obsConf = probe.rating;
            }

            dataRows.push([
              ...baseParticipantInfo,
              sessionName,
              sessionPattern,
              sessionCharacter,
              'Observation',
              index + 1,                 // Trial Index
              'observe',                 // Player Choice
              outcome,                   // Actual Outcome
              0,                         // Coins Earned This Trial
              sessionDataObj.observationRTs[index] || '',
              '',                        // Explanation
              obsConf,                   // Confidence (if this trial had a probe)
              ''                         // Session Total Coins
            ]);
          });

          // Explanation row (main sessions only)
          if (!isPractice && sessionDataObj.explanation) {
            dataRows.push([
              ...baseParticipantInfo,
              sessionName,
              sessionPattern,
              sessionCharacter,
              'Explanation',
              '',
              '',
              '',
              '',
              '',    // Reaction Time (ms) — placeholder
              sessionDataObj.explanation,
              sessionDataObj.confidence || '', 
              ''
            ]);
          }

          // Betting rows
          const totalBettingTrials = isPractice
            ? sessionDataObj.bettingChoices.length
            : BETTING_ROUNDS;

          for (let i = 0; i < totalBettingTrials; i++) {
            const choice = sessionDataObj.bettingChoices[i] || '';
            const reality = sessionDataObj.bettingRealities[i] || '';
            const coinsEarnedThisTrial = (choice && reality && choice === reality) ? 1 : 0;
            const rt = isPractice
              ? (practiceBettingRTs[i] || '')
              : (sessionDataObj.bettingRTs ? sessionDataObj.bettingRTs[i] || '' : '');

            dataRows.push([
              ...baseParticipantInfo,
              sessionName,
              sessionPattern,
              sessionCharacter,
              'Betting',
              i + 1,
              choice,
              reality,
              coinsEarnedThisTrial,
              rt,
              '',
              '',
              (i === totalBettingTrials - 1) ? sessionDataObj.coinsEarned : ''
            ]);
          }
        }

        // Practice session
        addSessionRows('Practice', {
          observationOutcomes: practiceObservedOutcomes,
          observationRTs: practiceObservationRTs,
          bettingChoices: practiceBettingChoices,
          bettingRealities: practiceBettingRealities,
          bettingRTs: practiceBettingRTs,
          coinsEarned: practiceCoinsEarned
        }, true);

        // Main sessions
        addSessionRows('Session 1', sessionData[sessionOrder[0]]);
        addSessionRows('Session 2', sessionData[sessionOrder[1]]);

        // Prepare payload for cloud function
        const payload = {
          participantID: participantInfo.SID || '',
          data: [header, ...dataRows]
        };

        // Send to Google Cloud Function
        fetch('https://us-central1-goog24-02.cloudfunctions.net/saveToNewSheet', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        })
        .then(response => {
          if (!response.ok) return response.text().then(text => { throw new Error(text); });
          return response.json();
        })
        .then(() => {
          alert("Data saved successfully! Your completion code is C52RX9MG (please copy paste).");
        })
        .catch(error => {
          console.error('Error saving data:', error.message);
          alert("Error saving data: " + error.message);
        });
      }

      // --- Event Listeners for Initial Flow ---
      // Event listener for participant info form submission
      document.getElementById('info-form').addEventListener('submit', (event) => {
        event.preventDefault();
        participantInfo.SID = document.getElementById('SID').value;
        participantInfo.age = document.getElementById('age').value;
        participantInfo.sex = document.getElementById('sex').value;
        console.log('Participant Info:', participantInfo);
        initializeExperiment(); // Start the experiment flow (this will hide participant-info)
      });

      // Event listeners for consent buttons
      document.getElementById('consent-button').addEventListener('click', () => {
        showScreen('participant-info'); // Go to participant info screen
        addQuitButton(); // Add quit button after consent is given
      });

      document.getElementById('decline-button').addEventListener('click', () => {
        showCustomAlert('You have declined to participate. The experiment will now close.', () => {
          window.close(); // Close the window
        });
      });

      // Event listener for Pre-trial screen continue button
      document.getElementById('ready-button').addEventListener('click', () => {
        startPracticeObservation(); // Start the practice game
      });

      // --- Initial Call to display the first screen ---
      // This will show the consent screen when the page loads
      showScreen('consent-screen'); 
    </script>
  </body>
</html>